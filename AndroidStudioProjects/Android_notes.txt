SETTING UP ANDROID STUDIO
1. Change themes and fonts
2. Enable auto import: Preferences>Editor>General>Auto import (All & unambiguous imports)
3. Auto generate boiler plate code & setting up naming conventions: Preferences>Editor>Code style>Java>code generation:(Field:m, Static:s)
4. Check SDK platforms available for building the versions of Android apps of interest.
5. Setup Emulator, if not connected an actual physical phone (Actual phone preferred, as emulators take up a lot of computer resources). Ensure to         pick the emulator for your computer's processor.

WORKING WITH ANDROID STUDIO
1. Gradle is a project setup & build tool, that generates an apk file for app deployment. Ensure it finishes building when starting Android Studio.
2. Main components of a project:
	- .java file which has the java code powering the activities
	- .xml file which has the layouts as viewed on the sample screen displayed. This has two modes, the graphical mode (Design tab & text mode 	which shows the xml code responsible for the current displayed layouts. Changing the code in this file changes the current project layouts.
3.Start of working on a project by choosing an app theme (determines the overall look & feel)
	- Via design view: Select from 'App Theme': On top of the layout view screen. (Note these these are separate from the layout files)
	- Via xml: App>res>values>styles.xml
4. Component tree: displays the layout type for the project and under it, all the visible components on the layout e.g textView, which displays text
	- Selecting a component displays it properties in the attributes window.
	- sp unit of measure (scalable pixel), density-independent pixels (dp)
5. Errors and warnings appear under the orange exclamation sign under the layout view.
6. All strings in the project just like the layouts and styles should also be in a separate file as resources and not hard coded i.e via the 		attributes window. To add an @string resource for this purpose:
	- Open the strings.xml file and add it, going it a title and actual string.
	- The in the attributes window under a component's /text/ field, link it to the resource by selecting it from the resource picker next to the 	attribute.
7. Graphics like strings, styles, colours and layouts are app resources and are stored under res(resources) folder, and in this case, the drawable 	folder. To add an image, save an image in the above folder, then in AS, pick an imageView component from the palette drop it in the layout.
	The property 'srcCompat' has the link to the saved image.
8. XML(extensible markup language): a tree structured meta notation, a set of rule to follow like punctuation. Used to create tag sets and use them 	to describe data. 	
	- The vocabulary of the tags differs in various application but the structure of the tags are the same i.e syntax and punctuation.
	- Applications of XML include: HTML, RSS, SVG.
9. AndroidManifest XML file is the file that holds information about the app, included resources it has and what the app is allowed to do etc. In 	here we can tell the app which launcher icon to use instead of the default, if we have included our customs ones. (Include different res 	images for the app launcher to accommodate different screen resolutions. The phone using the app will choose the launcher to use.
10. An Android project (collection of files that make up the intended result) has four main elements:
	- A manifest file: 
	- Java files: Programming logic of the app
	- Resources: Design of the app (colours, strings, images, dimensions, layouts etc)
	- Gradle files: App builder, collates all the required files, runs tests on the files and if passing produces an apk file that is used to 	instal the app.
11. Visit flatuicolors.com for hex values for different colours.
12. To create launcher icons of different sizes, right-click on the res folder and select image assets, select launcher	icons and pick a master image 	that is at least 512*512 pixels and this tool will generate an icon pack for all sizes required. (Largest icon as per google - 192*192. If we 	create the files manually, add them to their respective mipmap folders, then update the AndroidManifest.xml file with the new file names.
	- Create both square and round ones.

LAYOUTS (CONTAINERS FOR ARRANGING COMPONENTS ON THE SCREEN)
1. Relative layout: Allows positioning components relative to each others position.
2. Linear layout: Allows arranging of components vertically (on top of each other) or horizontally (side-by-side).

LINKING COMPONENTS TO JAVA ACTIVITIES
1. Create a variable to hold a layout element
2. Retrieve the element and store it in the variable
3. Use the element value stored in the variable to manipulate the element using Java code.

ACTIVITIES
- The entry point for a user's interaction with the app as well as navigation within the app, functionality for which is provided but the ACTIVITY class, by invoking an instance of the class.
- The rationale for activities is because user interaction on a mobile platform does not always start from the same point like on a desktop platform i.e you can launch an app from theme screen or it can be launched from within another app. The calling app then invokes an activity in the other app rather than the app as a whole.
- App activities as implemented by subclassing the Activity class.
- Activities provide the window for am apps GUI which may fill the screen or not. An app may have multiple activities implementing different screens and some at the same time to display on different sections of the screen.
- There is always a main activity which is implements the first screen on app launch, which then starts other activities.
- Activities are strictly dependant on each other, hence the ability for cross-app activity invocation.
- To use an activity in an app, it must be registered in the app's manifest and it's life cycle must be managed appropriately.

DESIGN PATTERN
- A proven blueprint/template for solving a problem in software engineering.
- MVC is a way for devs to organise files & structure code. Each resource is maintained in a specific file and these file are organised in a specific way to reduce the complexity of the app, improves standardisation for app building, enforces modularisation and enhances concurrent development of all the app section.
- The app code should also be organised in this way so that different code file do specific things an organised properly.
- MVC: Models manages data between the app and the database, Views managed the UI and controllers handles the communications between the models and views.

APP OVERVIEW
- An app is made up of various part that communicate with each other to achieve a goal. These could be components e.g buttons which send messages like click an Android activity which then determines what should be done when such a message is received.
- These parts are visible and invisible, one should learn how each of these part communicate.
- When an app is launched, the onCreate() message is sent by the OS to the app's MainActivity to load up everything needed to display the app.
- Apps are 'Event-driven' i.e work on the backdrop of events happening.

ACTIVITY LIFECYCLE (Messages the app receives from the OS)
- The lifecycle begins with when the app is launched, then it become visible to the user, then when the user switches to another app, it recedes into the background and if the user does not revert to it, it gets killed and system resources it was utilising get reclaimed for use by other apps.
- The OS notifies the app of its state in each stage of it's life cycle , thus devs is make their apps respond to these messages.
- Stages of an Android	app / Activity lift cycle are:
	
	1. Non-existent - app is not launched yet
	2. Stopped - app is running in the background
	3. Paused - app is active but not the currently main focus app
	4. Running - app is fully in the foreground and the user is interacting with it

NB) Only one activity across the entire Android system can be running at any one time, if another is becoming fully active, the current one will be paused.

- OS messages to the app to notify it of its changing states:

	1. OnCreate() - changes activity from non-existent to stopped: Loading up all resources into memory in preparation for display
	2. OnStart() - changes activity from stopped to pause: activity is now visible.
	3. OnResume() - changes activity from paused to running: activity is now in the foreground and the user can interact with it.
	4. OnPause() - changes activity from running to paused: when the user  presses the power button or the screen has timed out. No user 				interaction, though app may be visible or partially visible. (You can continue with UI updates but saving user changes and data should be done here.
	5. OnStop() - changes activity from paused to stopped: when the user presses the home button or launches another full screen app. App is running in the 	background. Prepare stopping UI updates e.g videos playing, stop camera etc.
	6. OnDestroy() - changes activity from stopped to non-existent: activity is about to be shut done, thus close and clean up including closing remote 		server connections etc.

- Activity life cyle with screen rotation: the app is killed then re-lauched with the new screen configs and goes through all the stages above, with an additional callback right after OnPause() called onSaveInstanceState(), where state data can be saved to ensure the app's current state continue right where it was left off e.g. game scores.

CONSTRAINT LAYOUTS
- Nested view hierarchies, layouts inside other layout then components in the nested layouts.
- Hard layout values should be avoided, rather setting rules such as match_parent, wrap_content making the app adapt to the screen on which it is running.
- As developers, do some research as to which devices we should support, since we can't support all the screen sizes, types and orientations.
- Developer.android.com documentations & dashboard > Multiple screen offers stats on what screen are most popular, int terms of size and resolution.
- Flat-view hierarchy, no nesting of layouts or components.
- Constraint layout require dependancies in the grade file, thus converting from a nested hierarchy layout (with relative and linear layouts) to a flat hierarchy                    layout (with constraint layout). Creating a new constraint layout project will add these xml dependancies auto.

NB) MATERIALSPALLETE.COM > Color palettes suited for android design.
NB) RESOURCE QUALIFIERS - by Android to distinguish resources to be used for various circumstance e.g. image sizes based on screen size, different layouts based on the phone orientation, different string values for different locales etc.

GRADLE
- Tool used to configure and build files.
- build.gradle (Project:) - contains info about the whole project (all modules)
- build.gradle (Module.app) - info about a specific app/module within the project:
	
	1. minSdkVersion: tells the OS and play store the minimum android version the app can run on. Set based on the minimum sdk version you want to support
	2. targetSdkVersion: tells the OS how to treat the app e.g look and feel by knowing which features are supported by the app. Usually better to set to the latest sdk 	version to support new features.
	3. compileSdkvesion: tells gradle what sdk version to use to compile the app under development. Should be equal to the target sdk version, so as to enable the newest
	android features in the app.

- Dependancy Mgt: a dependancy is a library (code written by someone else to do something, mostly to enable the use of some features). If for example you want to include a cool feature in your app enabled by some library e.g .jar file (combination of java executable class files):

	1. Change project view to 'project view'
	2. Add a directory under your app folder and call it 'libs'
	3. Download the .jar file and place it in the lib folder created
	4. Ensure in build.gradle(Module.app) under 'dependancies' that the 'libs' folder is included {(for v3) implementation fileTree('dir: 'libs', include: ['*.jar'])} 	to ensure gradle includes the new file(s) when compiling the project. Then sync the project.

- The above manual process is both tedious and does not update the libraries automatically to incorporate new features and bug fixes.
- To automate the processes of adding dependancies in, use REPOS. The most common ones for android dependancies are JCenter and Maven Central. JCentre is included in build.gradle(Project: automatically for all projects and is the biggest java and android repo.
- Include in the build.module(App) file the specific library URL from the specified repo to include under dependancies e.g. (for v3)implementation 'com.loopj.android:android-async-http:1.4.9' then sync the project for gradle to download and include the library.

- To know which library to include google if it exists for a feature you would like to incorporate in your project, instead of having to re-create the feature.

ANDROID MANIFEST FILE
- This file contains details about the app and the permissions it has e.g what resource on the host OS and device it has access to.

INTENT
- Is an android component that handles intercommunication between apps and activities by holding and availing information about the task/job to done. The are used to navigate between activities and are also used to request for job handles for which no activity or app has been specified to handle, thus the OS will avail the activities and apps that are capable of handling the job request. They can also specify which particular activity should handle the job.
- Intent filter are used by the OS to match activities to actions e.g the activity to start first when the app launches e.g MAIN. They also have categories to narrow down which components can handle and action. Android docs has many more category that can be used.
- Extras are passed along in intents containing data that will passed across activities or apps.






