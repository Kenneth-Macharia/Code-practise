"Note","Course","Module","Clip","Time in Clip","URL"
"# WEB DEVELOPMENT\n## MODULE 1: Intro\n- Websites (Static) vs Web applications (Interactive)\n- Architecture and protocols\n\n## MODULE 2: Web Dev Team\nSkills requirements:\n- Client-side (UI/UX skills - HTML, CSS, JavaScript)\n- Server-side (Data manipulation and business logic, more flexible due to less restrictions on supported tech by browsers)\n- Full stack skills\n- System, DB and Network administration (DevOps)\n\n## MODULE 3: Client-side\n- Ensure testing web apps on multiple browser to ensure consistence of the UX.\n- Responsive webpages using CSS\n- JavaScript Object Notation (JSON) used to transfer data to and from the server.\n- Asynchronous JavaScript and XML (AJAX):\n\nAsynchronous > (server requests) in the background so as not to interupt other on-going UI processes as opposed to synchronous which have to complete before anything else happens (App appears frozen)\n\nXML - data exchange format replaced by JSON.\n\nAJAX enable updating only portions of a webpage as opposed to the whole page, thus rise of more complex client side app with more server like features and more frameworks and libaries to build in these features:\n- jQuery: collection of built in functions to make AJAX requests and update specific part of a weba page with the results from the server.\n- Client side frameworks (Angular(Google), React(Facebook), Vue(former Google employee)) provide the scaffolding for websites and have lead to the development of SPA (single page applications) - all functionality for a loaded page partially added incremetally by heavily using AJAX.\n - This enables the app to be extremely responsive and fast.\n\n## MODULE 4: Server-side\n- Use tech that can communicate over HTTP and send and receive JSON data.\n- Better option is to use frameworks that bundle the necessary infrastructure to communicate with the client over HTTP e.g. ASP.Net (C#, VB.Net), Java, Python, PHP {& their web frameworks}, Nodejs.\n- Execution environment (Windows & Linux)\n- Hosting: on-site or cloud vendors","Web Development: Executive Briefing","What Is Web Development?","Web Development Overview","0:03","https://app.pluralsight.com/player?course=web-development-executive-briefing&author=brice-wilson&name=d1f01147-f99e-429e-9978-e90e765f4ca4&clip=0&mode=live&start=3.413927&noteid=f0ad9d58-5bd7-4a7d-81da-e92f20f058fa"
"# DATABASES\n## MODULE 1: Problems DBases solve\n- Databases go beyond just storing data, they essentially help eith problems that arise after we have stored the data e.g. scaling, changing, sharing, efficient access, inter-dependancy, consistency, security etc.\n- DBMS software is used to manage the rules goeverning the databases e.g Ms SQL server, Oracle etc.\n\n## MODULE 2: Core features\n- RDBMS - classic DBMS released from the 70s (Oracle), (80s-IBM DB2, PostgreSQL, Ms SQL Server) (90s-MySQL, Ms Access) to early 2000s (SQLite).\n- Realational integrity - keeping data consistent by e.g no deleting a row if a related row still exists in another table.\n- Data modelling - coming up with the database schema. \n- The schema is a diagram showing all the tables in a DBase with their columns and all PK-FK relations between them.\n- All the actions you can do on a DBase - CRUD using SQL.\n\n## MODULE 3:  Business Use\n- Transactions in RDBMS enforces data consistency and integrity by ensuring that an action on a database either executes to the end of does not at all, else any half-made changes are rolled back to normalize the data.\n- ACID - characteristics of a valid transaction.\n\nAtomic - do all parts of a transaction or do none.\nConsistent - a transaction must the database from one valid state to another valid state.\n- Isolated - the part of the database being changed will not be visible to other users until the current transaction is complete.\n- Durable - once a transaction is complete, then its forever as saved until intentionally deleted.\n\n- These features come std in RDBMS.\n\n## MODULE 4: Limitations of RDBMS\n- While RDBMS are good for dealing with  predictable data, their rather inflexible schema demands and not ideal for situations where data scales rapidly or changes format without notice or become distributed almost immediatly, and to cater for these current needs we need a different type of DBMS.\n- NoSQL dont have features of the RDBMS but are also not similar to each other like the RDBMS.\n- Why NoSQL over RDBMS? Cost, Scalabilty  and Speed.\n- These days though there are setup that have both types depending on the specific needs - Polyglot persistence.\n- There are also DBMS that have features from both types - NewSQL(focus more on NoSQL +s e.g Google Cloud Spanner, Apache Ignite), Multi-model (Azure Cosmos DB, Oracle NoSQL).\n","Databases: Executive Briefing","Introduction: The Problem Databases Solve","Course Overview: What to Expect","0:04","https://app.pluralsight.com/player?course=databases-executive-briefing&author=simon-allardice&name=54ed67be-bb64-4913-abb8-43161e683a20&clip=0&mode=live&start=4.782219&noteid=78b12a8f-88d1-4f1b-81d0-7047cb48a360"
"# DATA SCIENCE\n## MODULE 1: Importance of Data Science\nEnables businesses to make informed decision using data in a scientific method i.e.\n\n- Ask a question\n- Form a hypothesis\n- Design an experiment\n- Collect data\n- Analyze the data\n- Draw a conclusion on the hypothesis\n- Take action based on the conclusion\n\nMake smarter products - use machine learning, anticipatory design and telemetry data to improve product design and add give more value to the customer and also learn about the cust omers from the data collected to create even better products.\n\nAutomation - enables automating task that previously could only be done by humans thus releasing humas to work on more value adding tasks, reduce labour costs and reduce defects.\n\n- Applications of data science, stocks trading, baseball player selection, retail sales (online stores), autonomous warehouses.\n\n## MODULE 2: What is data science\n- Intersection of computer science, Math and stats, domain knowledge that seeks to gain insght from data science.\n- Tranform data into knowledge to drive decision making.\n\nSkills needed in data science:\n\n- Programming\n- Working with data\n- Descriptive statistics\n- Data visualization\n- Statistical Modelling\n- Handling Big Data\n- Machine Learning\n- Deploying data science solutions\n\nTools for data science:\n- Programming languages (SQL, Python, R)\n- RDBMS (MySQL, MsSQL Server, PostgreSQL)\n- Big Data platforms (Spark, Hive, MongoDB, Redshift)\n- BI & reporting (Ms Excel, Power BI, QlikView)\n\n## MODULE 3: Getting started with data science\nFeatures of data driven orgnizations:\n- DS strategy\n- People to execute the DS strategy (skilled and trained)\n- Data (collecting, cleaning & maintaining)\n- Technology (Analyzing data and automate decision making processes)\n- DS culture (correct DS mind-set by encouraging data driven behaviour and discourage non-data driven behaviour)\n\nData Science hierachy needs:\n- Need to collect data\n- Need to organize the collected data\n- Need to analyze the organized data\n- Need to make predictions from data\n- Need to automate\n\nDS is the stepping stone to being an AI driven organization.","Data Science: Executive Briefing","Why Is Data Science Important?","Introduction","0:07","https://app.pluralsight.com/player?course=data-science-executive-briefing&author=matthew-renze&name=fa282ea4-b152-494f-adfc-1e23e130954c&clip=0&mode=live&start=7.770684&noteid=322bcb68-0cc3-4733-88e8-048c3ba98a95"
"# ANDROID APPLICATION BASICS (Jim Wilson)\n## MODULE 1: Building a simple app\n- Download and install Android Studio\n- Android Studio - a complete Android dev env\n- Layout files describe the UI\n- Activity is codea and functionality to present the UX\n- Android Emulator to run and test apps from the desktop (aka AVD - Android Virtual Device)\n\n## MODULE 2: Designing and Planning our app\n- The APP (NoteKeeper) > A note keeper which can:\n - Display notes\n - edit existing notes\n - Create new notes\n- The note structure:\n - Course: Course name & Note must correpsond to an actual course\n - Note title: User entered value to ID note\n - Note text: User entered value serving as content of the note.\n- APP long term plans:\n - Automated testing of logic & UI/UX\n - Card style lists\n - Slide-out draw navigation\n - Track cpmplted module\n - Brand -based themes\n - Device & language adaptability\n - Support for users with accessibilty needs\n - User customization\n - SQLite support\n - Make note data available to other app\n - Display notifications\n - Read/Save data in the background\n - Display note info on home screen via widgets\n- Rough design of APP starting point:\n - Draft screen showing notes: A list of notes with a create new note button\n - Clicking on a note transfers to another screen showing the note details\n - Clicking on the create new note button  , transfers to a blank note to add details.\n- Polished design:\n - Visual representation of the two screens of the app on the actual device screen\n - Main showing list of notes & APP name in the header. Each note shows the course (in heavier font), and the note title below the course name (in a lighter font) and a floating 'plus' create new note button.\n - The edit screen will show details of an opened note, the note's course as a dropdown, field to to display and enter the note title ans field to display and enter note content. Also on the header alongside the screen title ('Edit Note'), will be a button to go back to main screen (effectively saving the note) and a button to navigate to the next note.\n\nNB:\n- Android dashboard gives current android version usage to inform what SDK version to use when developing an app.\n- Android has two versionng identities:\n - Platform using dot (4.0, 4.1...) - Where app will run\n - SDK using inter versions (15, 16...) - everything devs need t develop apps that will run on a certain android platform.\n\n## MODULE 3: Activities and Activity/Layout interactions\n- Activity: a single focused thing, a user can do:\n - Serves as a place to present the UI by providing a window. UI is built with view derived classes\n - Have a lifecycle which are a series of methods. Uses the onCreate method to initialize the activity\n- Views: \n - Basic building block of UI\n - Drawing and handling events\n - Examples e.g Widgets, Text (palette)\n- View groups: special view that holds other views\n- Layout:\n - Special invisible group\n - Handles view positioning behaviour (responsive behaviour for different screen sizes)\n - Layout classes provide positioning flexibility e.g arranging child views (which can include other layout classes)\n - Sepcific positioning behaviour depends on the layout class.\n - Layout classes include: Blocked-out area, used for creating predictable areas of the screen that items may go into, has only one direct child.\n - Scroll view: scrolling capability.\n - LinearLayout: horizontal/vertical arrnagement (support weighted distribution).\n - RelativeLayout: for positioning in relation to a view, another layout or a parent layout. (to the right or left/ along the top edge or bottom edge)\n- Layout creation: Traditional layout classes have challenges on both runtime & design time because of layout nesting, and manually working with alot of XML, since UIs have become so much richer.\n  - ConstraintLayout is the answer to above challenges (Released by Google in 2017). Its the only layout class needed for working with rich UIs and requires little to no XML needed to work with it:\n - This class uses constraints and the children inside them leverage the constraints (relative size/position(children), ratio based size/position(%), group size/position, group/chain size/position (where e.g multiple views can be displayed across the width of the display), weighted relationships (centred slightly to the left), guide-based size/positions (invisible views, at runtime are used to position other views).\n - ConstraintLayout should have atleast a horizontal & vertical constraint else it will be positioned at 0,0. Setting more e.g left and right will cause the view to be centred.\n - Circles on views can be dragged to other views circles to create a constraint relatinship (thus resizing one view automatically resizes the related view)\n - Squares set fixed sizes for the views.\n- Activity/ Layout relationship:\n - Create user experience using Java code to tight the activity to the layout.\n - We could use code to create class instances, relationships and properties, but we use layout files instead (XML files using the designer).\n - The acvitivity code has no relationship with the XML layout file and must load the files it needs. This is via the setContentView method.\n - The activity must then access the views in the layout via the view reference by using the findViewById method which returns a reference of type view and we cast (convert type to another - done by specifying the type in parenthesis infront of the variable to be converted) that to the type of view class required.\n - To find the layout resources (ID values) we use the R class. It has bested classes i.e. R.layout, R.id etc.\n- Populating a spinner:\n - Needs a layout for the default (current selection)\n - Another for each of the available selections within the spinner.\n - We also need to get the data to populate the selections.\n - We need an Adapter class to manage all these aspects of spinners.\n- SUMAMRY:\n - Activities present our user interface\n - The building blocks of of the UI are the views e.g Layouts (positioning & repsonsiveness), ConstraintLayout (only one we need).\n\nMODULE 4: Working with Activities\n- Android is a component-oriented platform e.g activities.\n- Actitivites cant directly create one another rather rely on INTENTS to interact.","Understanding Android Application Basics","Building a Simple App","Introduction","0:10","https://app.pluralsight.com/player?course=android-application-basics-understanding&author=jim-wilson&name=android-application-basics-understanding-m1&clip=0&mode=live&start=10.992322&noteid=c5e15d97-8f8e-40ab-bc6b-24b01b5c4cd5"
"# How Git works\n# MODULE 1: Intro\n- Porcelain git commands (high level): the common ones e.g add, commit, push, pull etc.\n- Plumbing git commands (low level): advanced ones e.g cat-file, hash-object etc.\n- Git is a distributed revision control system.\n- Also a content tracker\n- At its simplest, its a persistent map, a structure that maps keys to values and is stored on the local disk.\n- The values are btyes e.g. contents of a file. Furnishing a value to git, it will calculate a unique hash key for the value using the SHA1 alogrithm & git will use the hash key to store the content value it reps.\n- Git is persistent in that it saves hash keys generated in a git repo created when you initialize a folder as a git repo (creates a hidden .git control file).\n- Inside the .git file there is an objects file where the hash keys are stored, each in their own folder named using the first 2 characters of the hash key and inside the folder a file representing the key named using the rest of the hash key characters. (blob > a generic pc of data).\n-  Using some plumbing commands:\n - Generate a SHA1 key for text ""Apple pie"" > echo ""Apple Pie"" | git hash-object --stdin\n - Persist the string to a repo, first initlize a repo to store the SHA1 key for the content > git init, then generate the hash key and pass the argument -w (write) > echo ""Apple Pie"" | git hash-object --stdin -w\n - To get the type of a particular key e.g. 'blob' for some content > git cat-file -t (type)\n - To get the actual value represented by the hash key > git cat-file -p (pretty print)\n- Git as a content tracker:\n - The git objects database stores SHA1 keys for everything in a git repo. Content (file contents NOT file metadata) are stored as blobs and references to other blobs are stored as trees.\n - If a file has similar contents to another they will have the same SHA1 keys.\n - Commits also have SHA1 keys with tree SHA1 keys inside beside the commit text values, which refer to the file & directory content commited.\n - Use git log to view all commits and their SHA1 keys.\n- Versioning:\n - Since all commits are linked, then all except the first have a parent.\n - The other commits also have a new SHA1 tree key to represent the new contents, if a file has changes and keeps the same SHA1 keys for all unchanged blobs instead of duplicating.\n - Use > git count-objects to see how many objects are in the repo i.e how many hash key files representing blobs, tree, commits etc are there.\n- Tags:\n - Annotated tags: those that come a message and pointing to an objects. To create > git tag -a mytag ""I love cheesecake"".\n - You can cat-file a tag using its name or SHA1 key to view its details.\n- Thus git objects can either be:\n - Blobs\n - Trees\n - Commits\n - Annotated tags\n- Commit add the versioning feature to git's content tracking capability.\n\n## MODULE 2: Branches\n- Git places brnaches in the refs folder under heads. Inside a branch file is the SHA1 of the current commit.\n- Branches are references to commits, usually the current commit.\n- HEAD is a reference to a branch and is what tracks the current branch. Looking inside the HEAD file will show a ref to a branch file.\n- When a new commit is done, the current branch points to the new current commit but HEAD remains the current branch until the active branch is changed by git checkout.\n- Checkout means shift HEAD and update the working area to point to the commit when the checkout branch was created.\n- Merging branches mean updating a branches contents with anothers.\n - Conflicts occur between the current branch (HEAD) and the branch to be incorporate changes from i.e both are trying to change the same content. Resolve the conflict by accepting the deisred change:\n - Then stage the affected file for the next commit.\n - Commit the changes (which would happen automatically if a conflict have not happend. MERGES are simply commits but with two parents. After this the current branch now points to the new merge commit and since its the current branch, HEAD points to it.\n- Fast-foward happens when attempting to update a branch with contents that are already in another branch i.e there already exists a commit that has the same content as the attempted update e.g a merge. \n - Git in an attempt to be efficient and prudent with the repo, simply move the branch to the latest commit.\n- Detached branch happends when a commit is checked out instead of a branch, meaning HEAD moves to a commit instead of a branch, thus in no particular branch.\n - If further commits are done then a branch is checked out, then they are not referenced by any branch and those changes cant be reached other than by the SHA1 of the respective commits.\n - After awhile they will be garbage collect4ed and thos changed lost unless those changes can be associated with a branch:\n  - Use the commit SHA1 to check it out, then create a branch will now point at the commit, saving the commit changes, whcih can be merged elsewhere as needed.\n  - Using a detached branch state is a good way to experiment without affecting the core project.\n- Git rules:\n - The current branch tracks new commits\n - Wehn you move to another commit, Git updates the working directory with contents of the commit.\n - Unreachable object that are not referred to by a branch, HEAD or tags will be garbage collected after a while if not associated to either.\n\n## MODULE 3: Rebasing\n- This means aligning two divergent branches to share the same base commit, effectively merging the all the commits of both branches:\n - When rebasing a branch to another, git looks for the last shred commit between the two branches, then detaches all the branches commits since that shared commit and stacks them onto the last commit of the branch to rebase to.\n - The result tree structure is now singular with the rebased branch pointing to the last commit.\n - By checking out the rebase branch and  attempting to rebase using the already rebased branched, it will be fast fowarded to the last commit which the rebased branch is currently pointig to as there are no changes to be made the objects database.\n\n(NB) \n- Since objects are immutable, this implies that changing a commit, changes it data and thus its SHA1 hash key (including changing the parent commit), thus rebase actually makes copies of all the commits upto the last shared commit with the target branch then copies those to the top of the target branch, rather than movintg the commits (this essentially creates new commits with the same data except the parent commit data)\n- Since the copied commits are now unreacheable (have no branches/tags referring to them, they will be garbage collected with time, if you don't salvage them, by checking them out and creating  a new branch reference to them.\n- Rebasing vs Merging: though achieving the same result, choosing either is about the trade-offs:\n - Merging maintains the project history as it happend but leads to a confusing project history especially in large projects\n - Rebasing refactors the project history to make it neater but then the history becomes distorted. \n - Merging is safest thus use rebasing only when clear about the consequeces.\n- There are two type of tags which are used to mark a point in the project history:\n - Annotated tags that contain a tag message and a hash key referring to another object (a commit). Create one at the current commit > git tag -a\n - Light weight/ non-annotated tags which simply contain the ref hash key. Create one at the current commit > git tag\n - They are stored in the refs folder just like branches thus effectively behave like branches except their reference doesnt ever change unlike branches which change to point to the current commit (if  the branch is the current branch i.e HEAD.\n\n## MODULE 4: Distributed version control\n\n","How Git Works","Git Is Not What You Think","Introduction","0:15","https://app.pluralsight.com/player?course=how-git-works&author=paolo-perrotta&name=how-git-works-m1&clip=0&mode=live&start=15.029864&noteid=a381111f-db44-4a90-a91f-4ccd05ec33d1"
"# CLOUD SERVICES\n# MODULE 1: Introduction\n- Cost-benefit analysis of owned technology stack (applications & services, libraries & frameworks, Dbases & services, OS, hardware) vs cloud computing especially when scaling and de-scaling resource needs.\n- Virtualization - a computer simulating other computers such that an OS (Guest) can run on the simulated computer (virtual machine) as if it was a physical computer. A virtualization software (Hypervisor) needs to be installed on the host OS installed on the actual physical computer, to enable the virtualization feature, after which as many as is possible virtual computers can run on the one 'real' computer (Host machine).\n- Virtualization enables the software stack to be de-coupled from hardware as the pysical machine machine on which it runs is no longer paramount, this + high speed internet forms the basis of cloud computing.\n\n## MODULE 2: Cloud Technologies\nIaaS (Infrastructure as a service) Virtual machines that run on the service vendors' data centre servers, usually for leasing. (First in 2006 by Amazon's EC2)\n- This involves outsourcing the hardware stack so that organizations dont spend time & money purchasing and maintaining hardware. Since this is a pay-as-you-need service, scaling is efficient as well.\n\nPaaS (Platform as a service). This involves outsourcing some or all of the software services that their applications need. The vendor is responsible for the hardware and the support services and the organization only deploys their internal software to the cloud and pays pays for the resources consumed e.g storage, bandwidth and compute time.\n- The organization simply specifies the serives their software needs to run and the vendor creates a container/ environment tailor-made for them for them to run their software. This eliminates the need for orgsnizations to maintain virtual machines, even on the vendors hardware, greatly reducing maintainance costs.\n\nSaaS (Software as a services)\n- Involves outsourcing the entire technology stack to the vendor including the software that organizations use. The users then then consumes SaaS services via web browsers, tablet and mobile apps.\n\n## MODULE 3: Cloud vendor evaluation\n- Big 3 cloud vendors: AWS, Ms Azure and Google Cloud.\n- Others IBM, Oracle, SAP and Salesforce especially for enterprise solutions.\n\n- Cloud requirements & cost: what is the problem, anticipated scale, available resources and if other cloud services may be needed. Such analysis assists what vendor to go with.\n- Challenge is estimating resource consumption which is the basis for the pay-as-you-need cloud services.\n- Administration cost should also not be overlooked i.e staffing, training since some cloud computing solutions are complex.\n","Cloud Technologies: Executive Briefing","Cloud Services: Definitions and Motivations","What Is the Cloud?","0:30","https://app.pluralsight.com/player?course=cloud-technologies-executive-briefing&author=dan-appleman&name=db9af241-1c7b-45e7-b475-ba23c5dbf601&clip=0&mode=live&start=30.395487&noteid=622dd415-4fe7-4b69-a0cd-7f6d8a4cc41f"
"# WHAT IS PROGRAMMING?\n## MODULE 1: Introduction\nWhy do this?\n- You want be a software developer\n- Understand, work with or manage developers\n- Appeal\n\nWhat is a computer program?\n- Set of small specific instructions.\n- Complex programs are built from many small instructions in a specific order.\n- Involves thinking of the grand idea, breaking it into small steps and arranging them in the right order and finally testing that the result is what is desired.\n - Then write these instructions in a way a computer will understand them so that it can execute them.\n\nComputer languages:\n- Way to write source code (human readable instructions)\n- But since computers uderstand machine code only, the source code must be converted to machine code before a computer can run it:\n\n Compilation using a compiler bundled with the source code tool to convert the source code to machine code, not necessarily at runtime.\n\n Interpretation using an interpretor usually bundle on the running machine to convert the source code at runtime.\n\n Intermediate compilation which converts to an in-between code form called byte code then compiled just-in time to machine code.\n\nBasic computer architecture:\n- CPU runs the machine code. It is a made up of numerous on/off switches that can represent a state via either its on or off state. By grouping switches together we can represent numerous states/values.\n- A practical way to represent the states/values held by the switches at any one time is to use a series of 0s or 1s for the off and on states. This 0/1 representation of CPU switch states is binary code and is what machine code looks like. \n- A bit is a 0 or 1 and is the most basic representation of machine code.\n- A byte is a series of 8 bits used to represent specific values.\n- Machine code is however more efficiently represented in hexadecimal form and is a series of 16 bits.\n\n## MODULE 2: Rules of programming languages (Syntax)\n- Capitalization matters (True vs true)\n- Statements must be complete and have an effect.\n- Pseudocode is important for thinking through ideas, developing them and breaking down the ideas before actually writing source code.\n- Comments important for reading source code for both the author and other people.\n- Keywords specific to languages and have specific meaning in those languages.\n\n## MODULE 3: Data\n- Specifies what information is important to our program at this specific time.\n- Literal values are the actual values stored in variables.\n- Dynamically typed language where the data type of a variable is not tied to the variable rather to the value stored in the variable and as such the varible can hold any data type at different times. Some languages do not allow this and require a declared variable to have a specific unchangeable type before a value can be assigned to it.\n\n## MODULE 4: Program Flow\n- Conditional: If/ Else, AND/ OR (&&/ ||), switch/ case\n- Iteration: Loops\n\n## MODULE 5: Modularisation (Separation and grouping statements)\n- Functions.\n- Recursion: functions calling themselves, and is useful where the are unpredictable amount of items to act on e.g finding all the chess moves. They  result in leaner code to solve such problems.\n- Composite/ compound/ complex data types: combining more than one primitive data types:\n\n// define a new type\nstruct Game {\n     string title\n     string publisher\n     int yearReleased\n     boolean completed\n}\n// create a variable of that new type\nGame firstGame\n\n- Arrays and collections (dictionaries, trees, graphs etc)\n- OOP: focus on objects that can be defined as nouns and contains data (properties) and behaviour (methods).\n- Class is the blueprint for a house and the house is the object.\n- Instantiation: creating a new object of a class.\n\n## MODULE 6: Real world programming\n- Generic functionality (Library): a collecton of complete functions to be shared and re-used. These are simply imported into your code to avail their functionality e.g datetime, math, file I/O. We choose when to use libraries.\n- Frameworks: pre-written code that provides the structure for accomplishing a certiain task. Thus we can only add our functionality into it.\n- SDK (software development kit) - everything you need to develop, test and deploy software on a specific platform.\n- API (Application programming interface): how to interact with a system and not getting concerned with how the system works.\n\n- Choosing a programming language: \n  What development areas to focus on?\n  ","What Is Programming?","Introduction","Introduction: How to Think About an Infinite Machine","0:25","https://app.pluralsight.com/player?course=what-is-programming&author=simon-allardice&name=what-is-programming-m1&clip=0&mode=live&start=25.512486&noteid=5b00b891-a890-48ad-8805-777ad6c57c12"
"# LEARNING TECH IN THE MODERN AGE \n\n## MODULE 1: Knowledge vs Information vs Tools vs Skills?\n\n## MODULE 2: Learning Paths\n- Fundamentals: Where you learning the basics of the tech you are interested in, the language words and phrases. These concepts are widely applicable and they rarely become obsolete. Helps to learn and process information.\n- Information: Focus on implmentation of the fundamental concepts. This track concepts are highly dymamic and become obsolete quickly. These have to be backed by a solid fundamentals track. Specific knowledge you use to solve problems.\n- Skills: this is learning how to do something. These are mostly aqcuired practically, on the job. Turninig technology into reality. Ability to use knowledge to solve problems.\n\nBeginners solve problems slowly and the solutions may not be optimal while experts solve problems fast and the solutions are efficient and reliable.\nThe skills add value and people get paid to do things, not to know things.\n\n- Innovation/Expertise: Experts have acquired competency in a specific tech. They have and unserstanding of the fundamentals and have access to information required to solve problems and have the skills to solve problems in a timely manner. They can also id what problems cnat be solved and understand why. They are also creators of knowledge i.e throught their competency, they define standards and best practices and invent solutions.\n\n- Maximising Value:\nCompetency i.e Solid Fundamentals, Information and Skills is the surest way to maximize return on the investment for learning a specific tech.\n\nIt more advisable to achieve competence in an areas and switch to learning a new technology than to attain epertise in said  area unless there is a very good reason to expertise need. The returns will always diminish past competence.\n\n- Since time is the real cost of learning, then choosing the right domain to learn is crucial. Choose based on the value you will get in return be it monetary, reputation etc. Learning one tech involves sacrificing others hence getting it right quickly. Look at jobs and salaries for various tech and also platforms and architecture.\n\n- Time value of knowledge:\nFundamentals track  - knowledge here will likely be valuable for a long time and is easily transferrable.\n- Information track - due to frequent updates to tech, then this track is a continuous learning track.\n- Skills track: share characteritics with the fundamentals and informations track.\n- Innovation track is similar to the skills track.\n- The question would be how long to I anticipate to benefit from what I am learning, if longer then its most likely fundamental and less informatin thus validating the invenstment in learning the tech.\n\n3 Branches of knowledge in tech:\nHard skills:\n- Technology branch\n\nSoft skills - Most likely never be obsolete and are multpiliers to the hard skills:\n- Business and Finance branch\n- Leadership and Mangement branch\n\n## MODULE 3: Knowledge, Skills and Practice\n- Our biggest challenge today is not accessing information, rather filtering information, so as to consume only what is relevant and accurate.\n\n- Drunken sailor problem > Monte Carlo method\n\n- Academics are innovators on the fundamentals, making university education on of the best ways to gain a solid understanding of the fundamentals of tech but present weaknesses on the other tracks as the educators may not always work with the relevant tech.\n\n- Vocational schools are more likely to equip learner with information and skills as they are also more likely to be working with the tech in the field. They have less expertise in the fundametals since they less likely to be involved in fundamental research as the academics do.\n\n- Schools also provide equipment to learn and filtered information via set curriculum (Curation).\n\n- Schools also provide support via collaboration, examination, tutors and certifications as validation of fundmentals skills learned, skills via internships programs and labs.\n\n- Alternatives to learning technology:\n\nCuration - Where to start learn? Poor curation seriously increases cost of learning. Books are king here. Goal here is to have learning content in a logical learning order and relevance.\n\nKnowledge (Fundamentals or Information):\n- Information sources: Books, online courses (video equivalent to books), blogs & search (poor curation, poor focus on fundamentals and prone to less accuracy), product documentation (sometime not updated, has errors and lacking in curation).\n\nSkills (What pays): How to translate knowledge to skills. Observation, Practice (Use tech, solve practice). THERE IS NO SUBSTITUTE TO HANDS ON EXPERIENCE. Not just following examples but by SOLVING PROBLEMS. If not yours, then other peoples problems e.g on StackOverflow or open source projects.\n\n- Ensure formal education institutes offer  emphasis on teaching skills through practise and not just focusing on fundamental knowledge.\n\nSupport & Discipline: Tests, collaboration, teachers, informal training at work, seminar speakers, study groups at work or community, online communities (from online courses).\n\nExpertise (Not the best use of time unless neccessary, as attaining competence in an area is usually enough): techniques to gain skills are also the same to gain expertise only done after a long time.\n\nCertification: Defines competence domain and attests competence level in that domain.\n\nValue of a certificaton depends on underlying nature of test (peer review and documented work or exam based?) domain it covers, who issues it? If domain if informational, is it current?\n\nNB) Real world verifiable practice can be certification.\n\nFun: Don't only focus on tech for work, ty something for your own passion.\n\n\n## MODULE 4: What to learn today\n- Which track to focus on and how far to go?\n- What are my goals for learning any tech?\n\nFundamentals: Look for curation (what basics to learn) - Look at various course curriculum, online course, literature table of contents and find common units, especially those appearing at the beginning, these are more likely fundamentals.\n\nInformation: (Challenge here is up-to-date information). Web here is bettr. Look at date stamps, if more than a year old, be careful.\n- Don't worry about detail but focus on obtaining the information in an attempt to learn skills.\n\nSkills: First key thing is have a full test environement for the tech of interest.\n- Experiement with examples so as to get a deeper understanding of the material. GO BEYOND THE TUTORIAL EXAMPLES.\n- To gain competence you must use the tech practicaly to solve problems.\n\nExpert: Happens rather than is intentinal, by simply practising. But if to be acknowledged, be visual by contributing to solutions and interacting with people in the tech space, thus soft skills are essential as well.\n\nNB) Mix up the paths to stay motivated and relevant ie. Learn a fundamental, then learn how it can be used in the real world, then apply it by solving small problems.\n\n\n\n\n\n\n\n\n\n\n","Learning Technology in the Information Age","Learning Paths","Learning Paths","1:06","https://app.pluralsight.com/player?course=learning-technology-information-age&author=dan-appleman&name=learning-technology-information-age-m2&clip=0&mode=live&start=66.850304&noteid=65ccabc6-d87d-45ad-89d3-a3f31e626a7b"